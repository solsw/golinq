package typed

// generated by github.com/solsw/golinq/typed/typedgen utility

import (
	"reflect"

	"github.com/solsw/golinq/common"
	"github.com/solsw/golinq/enumerable"
	"github.com/solsw/golinq/errors"
)

// SliceEnumerable is an alias for []*enumerable.Enumerable.
type SliceEnumerable = []*enumerable.Enumerable

// ElemToEnumerable converts Elem to *enumerable.Enumerable.
// If 'el' is nil, *enumerable.Enumerable's zero value is returned.
func ElemToEnumerable(el common.Elem) (*enumerable.Enumerable, error) {
	var r0 *enumerable.Enumerable
	if el == nil {
		return r0, nil
	}
	r, ok := el.(*enumerable.Enumerable)
	if !ok {
		return r0, errors.WrongType(reflect.TypeOf(el), reflect.TypeOf(r))
	}
	return r, nil
}

// SliceEnumerableToSlice converts SliceEnumerable to Slice.
func SliceEnumerableToSlice(ts SliceEnumerable) common.Slice {
	if ts == nil {
		return nil
	}
	r := make(common.Slice, 0, len(ts))
	for _, t := range ts {
		r = append(r, t)
	}
	return r
}

// SliceEnumerableToEnumerable converts SliceEnumerable to Enumerable.
func SliceEnumerableToEnumerable(ts SliceEnumerable) *enumerable.Enumerable {
	return enumerable.NewElems(SliceEnumerableToSlice(ts)...)
}

// SliceToSliceEnumerable converts Slice to SliceEnumerable.
func SliceToSliceEnumerable(sl common.Slice) (SliceEnumerable, error) {
	if sl == nil {
		return nil, nil
	}
	r := make(SliceEnumerable, 0, len(sl))
	for _, el := range sl {
		t, ok := el.(*enumerable.Enumerable)
		if !ok {
			return nil, errors.WrongType(reflect.TypeOf(el), reflect.TypeOf(t))
		}
		r = append(r, t)
	}
	return r, nil
}

// EnumerableToSliceEnumerable converts Enumerable to SliceEnumerable.
func EnumerableToSliceEnumerable(en *enumerable.Enumerable) (SliceEnumerable, error) {
	return SliceToSliceEnumerable(en.Slice())
}

// EqEnumerable is an Equality for *enumerable.Enumerable.
var EqEnumerable = func(e1, e2 common.Elem) bool {
	// use the appropiate one or implement your own
	return reflect.DeepEqual(e1, e2)
	// return reflect.DeepEqual(e1.(*enumerable.Enumerable), e2.(*enumerable.Enumerable))
	// return e1.(*enumerable.Enumerable) == e2.(*enumerable.Enumerable)
}

// EqNilEnumerable is an Equality for *enumerable.Enumerable, respecting nil parameters.
var EqNilEnumerable = func(e1, e2 common.Elem) bool {
	if e1 == nil && e2 == nil {
		return true
	}
	if e1 == nil || e2 == nil {
		return false
	}
	return EqEnumerable(e1, e2)
}

package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

type data struct {
	Package, Type, Name string
}

var t = `package {{.Package}}

// generated by github.com/solsw/golinq/typed/typedgen utility

import (
	"reflect"

	"github.com/solsw/golinq/common"
	"github.com/solsw/golinq/enumerable"
	"github.com/solsw/golinq/errors"
)

// Slice{{.Name}} is an alias for []{{.Type}}.
type Slice{{.Name}} = []{{.Type}}

// ElemTo{{.Name}} converts Elem to {{.Type}}.
// If 'el' is nil, {{.Type}}'s zero value is returned.
func ElemTo{{.Name}}(el common.Elem) ({{.Type}}, error) {
	var r0 {{.Type}}
	if el == nil {
		return r0, nil
	}
	r, ok := el.({{.Type}})
	if !ok {
		return r0, errors.WrongType(reflect.TypeOf(el), reflect.TypeOf(r))
	}
	return r, nil
}

// Slice{{.Name}}ToSlice converts Slice{{.Name}} to Slice.
func Slice{{.Name}}ToSlice(ts Slice{{.Name}}) common.Slice {
	if ts == nil {
		return nil
	}
	r := make(common.Slice, 0, len(ts))
	for _, t := range ts {
		r = append(r, t)
	}
	return r
}

// Slice{{.Name}}ToEnumerable converts Slice{{.Name}} to Enumerable.
func Slice{{.Name}}ToEnumerable(ts Slice{{.Name}}) *enumerable.Enumerable {
	return enumerable.NewElems(Slice{{.Name}}ToSlice(ts)...)
}

// SliceToSlice{{.Name}} converts Slice to Slice{{.Name}}.
func SliceToSlice{{.Name}}(sl common.Slice) (Slice{{.Name}}, error) {
	if sl == nil {
		return nil, nil
	}
	r := make(Slice{{.Name}}, 0, len(sl))
	for _, el := range sl {
		t, ok := el.({{.Type}})
		if !ok {
			return nil, errors.WrongType(reflect.TypeOf(el), reflect.TypeOf(t))
		}
		r = append(r, t)
	}
	return r, nil
}

// EnumerableToSlice{{.Name}} converts Enumerable to Slice{{.Name}}.
func EnumerableToSlice{{.Name}}(en *enumerable.Enumerable) (Slice{{.Name}}, error) {
	return SliceToSlice{{.Name}}(en.Slice())
}

// Eq{{.Name}} is an Equality for {{.Type}}.
var Eq{{.Name}} = func(e1, e2 common.Elem) bool {
	// use the appropiate one or implement your own
	return reflect.DeepEqual(e1, e2)
	// return reflect.DeepEqual(e1.({{.Type}}), e2.({{.Type}}))
	// return e1.({{.Type}}) == e2.({{.Type}})
}

// EqNil{{.Name}} is an Equality for {{.Type}}, respecting nil parameters.
var EqNil{{.Name}} = func(e1, e2 common.Elem) bool {
	if e1 == nil && e2 == nil {
		return true
	}
	if e1 == nil || e2 == nil {
		return false
	}
	return Eq{{.Name}}(e1, e2)
}
`

const tcmp = `
// Less{{.Name}} is a Less for {{.Type}}.
var Less{{.Name}} = func(e1, e2 common.Elem) bool {
	// usually requires special implementation
	return e1.({{.Type}}) < e2.({{.Type}})
}

// LessNil{{.Name}} is a Less for {{.Type}}, respecting nil parameters.
var LessNil{{.Name}} = func(e1, e2 common.Elem) bool {
	// must go first
	if e2 == nil {
		return false
	}
	if e1 == nil {
		return true
	}
	return Less{{.Name}}(e1, e2)
}

// Cmp{{.Name}} is a Comparison for {{.Type}}.
var Cmp{{.Name}} = common.LessToComparison(Less{{.Name}})

// CmpNil{{.Name}} is a Comparison for {{.Type}}, respecting nil parameters.
var CmpNil{{.Name}} = common.LessToComparison(LessNil{{.Name}})
`

const cmpFlag = "--compare"

func parseArgs() (cmp, ok bool) {
	cmp = false
	for _, arg := range os.Args {
		if arg == cmpFlag {
			cmp = true
		}
	}
	if cmp {
		ok = len(os.Args) == 4 &&
			os.Args[3] == cmpFlag // --compare (if present) must be last argument
	} else {
		ok = len(os.Args) == 3
	}
	return
}

func nameFromType(t string) string {
	nn := strings.Split(strings.ReplaceAll(t, "*", ""), ".")
	return nn[len(nn)-1]
}

func main() {
	cmp, ok := parseArgs()
	if !ok {
		fmt.Printf("%s <packageName> <typeName> <%s>\n", filepath.Base(os.Args[0]), cmpFlag)
		fmt.Printf("  %s - include compare-related functions", cmpFlag)
		return
	}
	if cmp {
		t += tcmp
	}
	tmpl, err := template.New("typed").Parse(t)
	if err != nil {
		panic(err)
	}
	name := nameFromType(os.Args[2])
	f, err := os.Create("typed" + name + ".go")
	if err != nil {
		panic(err)
	}
	defer f.Close()
	err = tmpl.Execute(f, data{Package: os.Args[1], Type: os.Args[2], Name: name})
	if err != nil {
		panic(err)
	}
}

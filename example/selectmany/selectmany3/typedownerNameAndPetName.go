package main

// generated by github.com/solsw/golinq/typed/typedgen utility

import (
	"reflect"

	"github.com/solsw/golinq/common"
	"github.com/solsw/golinq/enumerable"
	"github.com/solsw/golinq/errors"
)

// SliceownerNameAndPetName is an alias for []ownerNameAndPetName.
type SliceownerNameAndPetName = []ownerNameAndPetName

// ElemToownerNameAndPetName converts Elem to ownerNameAndPetName.
// If 'el' is nil, ownerNameAndPetName's zero value is returned.
func ElemToownerNameAndPetName(el common.Elem) (ownerNameAndPetName, error) {
	var r0 ownerNameAndPetName
	if el == nil {
		return r0, nil
	}
	r, ok := el.(ownerNameAndPetName)
	if !ok {
		return r0, errors.WrongType(reflect.TypeOf(el), reflect.TypeOf(r))
	}
	return r, nil
}

// SliceownerNameAndPetNameToSlice converts SliceownerNameAndPetName to Slice.
func SliceownerNameAndPetNameToSlice(ts SliceownerNameAndPetName) common.Slice {
	if ts == nil {
		return nil
	}
	r := make(common.Slice, 0, len(ts))
	for _, t := range ts {
		r = append(r, t)
	}
	return r
}

// SliceownerNameAndPetNameToEnumerable converts SliceownerNameAndPetName to Enumerable.
func SliceownerNameAndPetNameToEnumerable(ts SliceownerNameAndPetName) *enumerable.Enumerable {
	return enumerable.NewElems(SliceownerNameAndPetNameToSlice(ts)...)
}

// SliceToSliceownerNameAndPetName converts Slice to SliceownerNameAndPetName.
func SliceToSliceownerNameAndPetName(sl common.Slice) (SliceownerNameAndPetName, error) {
	if sl == nil {
		return nil, nil
	}
	r := make(SliceownerNameAndPetName, 0, len(sl))
	for _, el := range sl {
		t, ok := el.(ownerNameAndPetName)
		if !ok {
			return nil, errors.WrongType(reflect.TypeOf(el), reflect.TypeOf(t))
		}
		r = append(r, t)
	}
	return r, nil
}

// EnumerableToSliceownerNameAndPetName converts Enumerable to SliceownerNameAndPetName.
func EnumerableToSliceownerNameAndPetName(en *enumerable.Enumerable) (SliceownerNameAndPetName, error) {
	return SliceToSliceownerNameAndPetName(en.Slice())
}

// EqownerNameAndPetName is an Equality for ownerNameAndPetName.
var EqownerNameAndPetName = func(e1, e2 common.Elem) bool {
	// use the appropiate one or implement your own
	return reflect.DeepEqual(e1, e2)
	// return reflect.DeepEqual(e1.(ownerNameAndPetName), e2.(ownerNameAndPetName))
	// return e1.(ownerNameAndPetName) == e2.(ownerNameAndPetName)
}

// EqNilownerNameAndPetName is an Equality for ownerNameAndPetName, respecting nil parameters.
var EqNilownerNameAndPetName = func(e1, e2 common.Elem) bool {
	if e1 == nil && e2 == nil {
		return true
	}
	if e1 == nil || e2 == nil {
		return false
	}
	return EqownerNameAndPetName(e1, e2)
}
